@page "/login"
@attribute [AllowAnonymous]
@layout LoginLayout
@using Client.Services
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using System.Text.Json
@using System.Security.Claims
@inject AuthService AuthService
@inject NavigationManager Nav
@inject IJSRuntime JS
@inject AuthenticationStateProvider AuthStateProvider

<h3>Login</h3>

<div style="max-width:300px; margin:auto;">
    <input @bind="username" class="form-control mb-2" placeholder="Usuário" />
    <input @bind="password" type="password" class="form-control mb-2" placeholder="Senha" />
    <button class="btn btn-primary w-100" @onclick="DoLogin">Entrar</button>

    <p class="text-danger mt-2">@message</p>
</div>

@code {
    private string username = "";
    private string password = "";
    private string message = "";

    private async Task DoLogin()
    {
        try
        {
            var token = await AuthService.Login(new Shared.DTOs.Auth.LoginRequest
            {
                UserName = username,
                Password = password
            });

            if (string.IsNullOrEmpty(token))
            {
                message = "Credenciais inválidas";
                return;
            }

            // 🔹 1. Salva o token no localStorage
            await JS.InvokeVoidAsync("localStorage.setItem", "authToken", token);

            // 🔹 2. Notifica o provedor de autenticação
            var customProvider = AuthStateProvider as Client.Auth.CustomAuthStateProvider;
            if (customProvider != null)
            {
                customProvider.NotifyUserAuthentication(token);
                
                // 🔹 3. Aguarda múltiplas vezes para garantir propagação completa
                await Task.Delay(300);
                
                // Verifica se o estado foi atualizado
                var authState = await AuthStateProvider.GetAuthenticationStateAsync();
                int attempts = 0;
                while (authState.User?.Identity?.IsAuthenticated != true && attempts < 10)
                {
                    await Task.Delay(50);
                    authState = await AuthStateProvider.GetAuthenticationStateAsync();
                    attempts++;
                }
            }

            // 🔹 4. Verifica o estado de autenticação atual
            var finalAuthState = await AuthStateProvider.GetAuthenticationStateAsync();
            var role = finalAuthState.User?.FindFirst(ClaimTypes.Role)?.Value ?? GetRoleFromJwt(token);

            // 🔹 5. Redireciona conforme o tipo de usuário
            if (role == "Master")
                Nav.NavigateTo("/clinicas", true);
            else
                Nav.NavigateTo("/materiaisconsumo", true);
        }
        catch (Exception ex)
        {
            message = $"Erro ao tentar logar: {ex.Message}";
        }
    }

    // Método simples para extrair o "role" do token
    private string GetRoleFromJwt(string token)
    {
        try
        {
            var payload = token.Split('.')[1];
            var json = System.Text.Encoding.UTF8.GetString(Convert.FromBase64String(PadBase64(payload)));
            var data = JsonSerializer.Deserialize<Dictionary<string, object>>(json);

            if (data != null)
            {
                // Procura por "role" (nome curto)
                if (data.TryGetValue("role", out var role))
                    return role?.ToString() ?? "";
                
                // Procura por "http://schemas.microsoft.com/ws/2008/06/identity/claims/role" (nome completo do ClaimTypes.Role)
                if (data.TryGetValue("http://schemas.microsoft.com/ws/2008/06/identity/claims/role", out var roleFull))
                    return roleFull?.ToString() ?? "";
            }

            return "";
        }
        catch
        {
            return "";
        }
    }

    private string PadBase64(string base64)
    {
        if (base64.Length % 4 == 2) base64 += "==";
        else if (base64.Length % 4 == 3) base64 += "=";
        return base64;
    }
}
